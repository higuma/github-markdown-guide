# 文字と行

[はじめに]
← [目次] →
[Markdownの構文]

------------------------------------------------------------------------

Markdownはテキスト形式でドキュメントを記述し、MarkdownからHTMLへの変換処理を行いHTMLを出力する。以下の内容では入力テキストは正しく[Unicode]エンコードされているものとし、文字エンコーディングの詳細には立ち入らない。

> 現在は大部分の環境で文字エンコーディングとして[UTF-8]が用いられている。GitHubのWebサービスは[UTF-8]に統一されており、本解説も[UTF-8]エンコーディングで作成している。

なおこれから示す用語はMarkdown仕様をマスターするためには必須の知識だが、Markdownで文章を書くためには必ずしも覚える必要のない用語も多い。後半の構文説明([インライン], [ブロック])へ進み、用語の意味が分からなければここに戻って確認すればよい。

## スペースとタブ

Markdownではスペース(U+0020)とタブ(U+0009)を空白文字として認識する。

文章中では連続するスペースは縮約され1個分にまとめて出力する。ただし[コードブロック]中では縮約されずそのまま処理される。また[リスト]などインデントを用いる文脈では行頭からのスペースの個数が文法としての意味を持つ。

タブはテキスト文中ではスペースと同じように1文字分の空白として扱われ、複数の連続は1個分に縮約される。ただし[コードブロック]中や、[リスト]などインデントを認識する文脈では空白4文字相当として処理される(縮約されずタブストップが有効)。

> ただしタブは環境により表示や動作が異なる場合がよくあるため本解説では一切使用していない。特定環境に限定した目的には使って構わないが、文書の可搬性を考慮した(より具体的には他のMarkdown環境でも使えるようにする)場合は避けた方がよい。

## 改行と空行

次の3通りのいずれかを行の終わりと認識する。

- 単独のラインフィード(U+000A)
- 単独のキャリッジリターン(U+000D)
- キャリッジリターン、ラインフィードのシーケンス(U+000D U+000A)

これらを<span id="改行">**改行**</span>と呼び、文書の先頭または前の改行の直後から次の改行までを一行と認識する。

一行の中に文字を全く含まないか、またはスペースとタブのみを含む行は<span id="空行">**空行**</span>と認識される。空行は[見出し]、[パラグラフ]、[リスト]、[表]などの文書構成要素の区切りとして用いられる。連続する空行はひとつ分として扱われる。

2個以上の連続する改行は上記定義により空行と認識される。3個以上いくつあっても縮約されて空行1個と同じ扱いになる。

改行に関しても[コードブロック]内部は例外で、改行は除去も縮約もされずそのままコードブロック内部に出力される。

## ASCII句読文字

Markdownでは基本的にテキスト文字列はそのままドキュメントとして扱う。そして書式設定([リンク], [画像], [コードスパン], etc.)や各種構文([見出し], [ブロック引用], [リスト], etc.)を表現する場合に**ASCII句読文字**を用いた文法を用いる。

[ASCII句読文字(ASCII puctuation characters)](https://higuma.github.io/github-markdown-guide/gfm/#ascii-punctuation-character)とは[ASCII印字可能文字](https://ja.wikipedia.org/wiki/ASCII#ASCII印字可能文字)(U+0020..U+007E)からスペースと英数字を除外した文字を指す。一覧は次の通り(全32種類)。

- U+0021..U+002F: `!`, `"`, `#`, `$`, `%`, `&`, `'`, `(`, `)`, `*`, `+`, `,`, `-`, `.`, `/`
- U+003A..U+0040: `:`, `;`, `<`, `=`, `>`, `?`, `@`
- U+005B..U+0060: `[`, `\`, `]`, `^`, `_`, `` ` ``
- U+007B..U+007E: `{`, `|`, `}`, `~`

Markdownの書式や構文の表現にはこれらの文字が用いられる。実例を示す。コードは短いが全部で20種類のASCII句読文字が用いられている(`_`,`*`,`~`,`` ` ``, `<`,`>`,`/`,`[`,`]`,`(`,`)`,`!`,`.`,`:`,`?`,`&`,`#`,`;`,`|`,`-`)。

```markdown
_italic_ **bold** ~~strikethrough~~ `code`

<var>N</var><sub>A</sub> = 6.022 × 10<sup>23</sup>

画像 → ![car](https://github.githubassets.com/images/icons/emoji/unicode/1f697.png?v8)

文字参照(絵文字) → &#x231A;&#xFE0F;

| ヘッダ | ヘッダ |
| - | - |
| セル | セル |
```

> _italic_ **bold** ~~strikethrough~~ `code`
> 
> <var>N</var><sub>A</sub> = 6.022 × 10<sup>23</sup>
> 
> 画像 → ![car](https://github.githubassets.com/images/icons/emoji/unicode/1f697.png?v8)
> 
> 文字参照(絵文字) → &#x231A;&#xFE0F;
> 
> | ヘッダ | ヘッダ |
> | - | - |
> | セル | セル |

### バックスラッシュエスケープ

ASCII句読文字の手前に`\`を付けるとMarkdown書式ではなく`\`でエスケープした通常文字と認識し、`\`を除去して文字として出力する。特に`\`を文字として出力する場合は`\\`とする。それ以外の印字可能文字の手前にある`\`は文字としてそのまま出力する。

- `\*` → \*
- `\-` → \-
- `\\` → \\
- `\1` → \1
- `\A` → \A
- `\あ` → \あ

ASCII句読文字はMarkdown書式の記述に用いられるが、逆にMarkdown書式とパターンが一致するASCII句読文字を含む文字列を文字としてそのまま出力する場合にバックスラッシュエスケープを用いる。

```markdown
**太字**

\*\*太字ではない**

~~打ち消し線~~

\~~打ち消し線ではない~~

> ブロック引用

\> ブロック引用ではない

1. リスト

1\. リストではない
```

> **太字**
> 
> \*\*太字ではない\*\*
> 
> ~~打ち消し線~~
> 
> \~~打ち消し線ではない~~
> 
> > ブロック引用
> 
> \> ブロック引用ではない
> 
> 1. リスト
> 
> 1\. リストではない

### バックスラッシュエスケープが効かない構文

バックスラッシュエスケープは[コードスパン]と[コードブロック]の中では作用せず、そのまま出力する。

``````markdown
`\*\*コードスパン**`

```c
// コードブロック
#include <stdio.h>
void main() {
    printf("\"Hello world!\"\n");
}
```
``````

> `\*\*コードスパン**`
> 
> ```c
> // コードブロック
> #include <stdio.h>
> void main() {
>     printf("\"Hello world!\"\n");
> }
> ```

## 句読文字

> **TODO**: セクション全体を強調書式の章(これから書く)へ移動する予定。
> 
> この用語は強調書式の判定にのみ用いられる。さらに通常の文書作成者にはあまり知る必要のない知識で、実装者レベルでなければ必要ない。

[斜体]及び[太字]の検出判定に**句読文字**(punctuation characters)を用いる。具体的には次のどちらかの条件に当てはまる文字が該当する。

- [ASCII句読文字]
- `P`で始まるUnicodeカテゴリ(`Pc`, `Pd`, `Pe`, `Pf`, `Pi`, `Po`, `Ps`)を持つ文字

一覧は次の通り。

- [付録 - 句読文字一覧](punctuation-characters.md)

> **TODO**: U+2060(WORD JOINER, `&NoBreak;`)のUnicodeカテゴリーは`Cf`で、`P`で始まるカテゴリーではないためGFM仕様書に従えばpunctuation characterには該当しない。
> 
> https://www.compart.com/en/unicode/U+2060
> 
> しかし実際の強調スパン判定では`&NoBreak;`は区切り文字として扱われている。次の文例は中間の`DEF`だけ斜体にする意図で、`_`は前後に区切り文字がある場合だけ強調書式になるが、次のように`&NoBreak;`を挿入することにより間に空白を入れずに区切りとして認識させることができる。
> 
> ```markdown
> ABC_DEF_GHI
> 
> ABC&NoBreak;_DEF_&NoBreak;GHI
> ```
> 
> > ABC_DEF_GHI
> > 
> > ABC&NoBreak;_DEF_&NoBreak;GHI
> 
> これをどのように説明すべきか検討中(確実に有用性はあるので必ず説明すべき)。なお他にもこのような文字コードはありそうだが、いちいち調査するともう一生掛けても終わる感じがしないので止めておく。

## 文字参照

MarkdownでもHTMLと同じ文字参照表現を用いることができる。次の3種類がある。

- [名前付き文字参照](#名前付き文字参照): `&{文字参照名};`
- [10進数文字参照](#10進数文字参照): `&#{10進表現};`
- [16進数文字参照](#16進数文字参照): `&#x{16進表現};` (大文字小文字区別なし)

### 名前付き文字参照

名前付き文字参照(named character references)はHTMLの[名前付き文字参照](https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references)と同じ書式を用いる。

```markdown
&lt; &gt; &amp; &copy;
```

> &lt; &gt; &amp; &copy;

ただしHTMLでは(後方互換対応のため)`;`を省略した表現も許可されているが、Markdownでは(文法明確化のため)必ず末尾の`;`が必要なことに注意。次はHTMLでは文字参照と認識するが、Markdownでは認識されず文字通り出力する。

```markdown
&lt &gt &amp &copy
```

> &lt &gt &amp &copy

一覧は次の通り。

* [HTML標準仕様書](https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references) (`Name`の末尾に`;`がない項目はMarkdownでは使えないことに注意)
* [Markdownで使える名前付き文字参照一覧](named-character-references.md)

### 10進数文字参照

10進数文字参照(decimal numeric character references)は`&#{10進表現};`の形式で表現する。

```markdown
&#48; &#65; &#97; &#12354; &#26716; &#128526;
```

> &#48; &#65; &#97; &#12354; &#26716; &#128526;

### 16進数文字参照

16進数文字参照(hexadecimal numeric character references)は`&#x{16進表現};`の形式で表現する(大文字小文字の区別なし)。

```markdown
&#x30; &#X41; &#x61; &#X3042; &#x685c; &#x1F60E;
```

> &#x30; &#X41; &#x61; &#X3042; &#x685c; &#x1F60E;

### 文字参照が効かない構文

文字参照も[コードスパン]と[コードブロック]の中では作用せず、そのまま出力する。

``````markdown
`&amp; &#65; &#x685C;`

```markdown
&amp;
&#65;
&#x685C;
```
``````

> `&amp; &#65; &#x685C;`
> 
> ```markdown
> &amp;
> &#65;
> &#x685C;
> ```

### 文字参照の必要性

Markdownでは文字参照を使う必要はあまりない。

HTMLはマークアップ優先の文法規則で、例えば`<`,`>`は要素タグに用いられる(例: `<p>`)。そのため "x < 10" はHTMLでは文字参照を用いて`x &lt; 10`としなければならないが、Markdownでは`x < 10`とそのまま書いてよい。HTML出力時にこれらの文字を検出し、適切にHTML用文字参照に変換する。

またMarkdownの書式設定と区別する場合は代わりに[バックスラッシュエスケープ]を使えばよい。例として`2*a*b`をテキストとして出力する場合を考える。そのまま書くと中間の`*a*`を斜体と認識するため、次のどちらかの方法を用いる。どちらでもよいが[バックスラッシュエスケープ]の方が楽に書ける。

- 未処理: `2*a*b` → 2*a*b (`*a*`が[斜体]になる)
- [文字参照]: `2&ast;a&ast;b` → 2&ast;a&ast;b (これでもよいが...)
- [バックスラッシュエスケープ]: `2\*a\*b` → 2\*a\*b (この方が簡単)

> ただしMarkdownでも文字参照の使用が有効かつ適切な状況が時々ある。これらは応用編として[文字参照の応用](texts.md#文字参照の応用)にまとめた。

------------------------------------------------------------------------

[はじめに]
← [目次] →
[Markdownの構文]

[ASCII句読文字]: #ascii句読文字
[Markdownの構文]: syntax.md
[Unicode]: https://ja.wikipedia.org/wiki/Unicode
[UTF-8]: https://ja.wikipedia.org/wiki/UTF-8
[はじめに]: intro.md
[インライン]: inlines.md
[コードスパン]: code-spans.md
[コードブロック]: code-blocks.md
[バックスラッシュエスケープ]: #バックスラッシュエスケープ
[パラグラフ]: paragraphs.md
[ブロック]: blocks.md
[ブロック引用]: block-quates.md
[リスト]: lists.md
[リンク]: links.md
[画像]: images.md
[斜体]: bold-italic-strikethrough.md#斜体
[表]: tables.md
[太字]: bold-italic-strikethrough.md#太字
[見出し]: headings.md
[目次]: index.md
[文字参照]: #文字参照
