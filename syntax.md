# 文法の構造

[文字と行](characters.md)
← [目次](index.md) →
[インライン](inlines.md)

------------------------------------------------------------------------

Markdownは出力形式であるHTMLと同様の木構造に基づいた文法解析を行う。Markdownにおける文法上のアイテムには大きく分けて次の2種類がある。

- [インライン] - テキストの一部として文字列内の順番に配置されるアイテム
- [ブロック] - 1行以上の大きさを持ち、行で区切られるアイテム

> (参考)これらはHTMLのインライン/ブロック要素に由来する(次を参照)。
> 
> - [MDN - インライン要素](https://developer.mozilla.org/ja/docs/Web/HTML/Inline_elements)
> - [MDN - ブロックレベル要素](https://developer.mozilla.org/ja/docs/Web/HTML/Block-level-elements)
> 
> なおインライン/ブロック文法モデルはHTML 4.01までの旧式で、現在のHTMLは[コンテンツカテゴリー](https://developer.mozilla.org/ja/docs/Web/Guide/HTML/Content_categories)という新しいモデルを用いている。ただしMarkdownは旧モデルを基礎としており、新モデルとの関係はあまりない。

## インライン

Markdownの文法構成アイテムの中で、テキスト文字列中のシーケンスとして配置するものを**インライン**と呼ぶ。ここでは一般的なMarkdownのインラインアイテム一覧を示す。

- インライン
    - [通常テキスト]
    - [太字、斜体、打ち消し線]
    - [リンク]
    - [画像]
    - [コードスパン]
    - [HTMLインライン]

以上が標準的なMarkdownのインラインアイテムだが、これらとは別にGitHub専用のインライン記法がいくつか存在する。GitHub特有の記法に関しては後の[GitHub Markdown実装]で説明する。

> GFM仕様書ではインラインで用いるHTML要素を「生HTML」(raw HTML)、ブロックで用いるものを「HTMLブロック」(HTML blocks)と呼んでいるが、これでは用語に統一性がない(raw HTMLは「HTML直接入力」という意味なので本来インライン/ブロックの区別とは無関係)。
> 
> そこで本ドキュメントでは用語を修正し、インラインで用いる要素を「HTMLインライン」とした(これなら全体の筋道が通る)。

> **ここからTODO**: GFM仕様書は体裁上は「CommonMark仕様書の完全上位互換のため加筆のみ」という方針で書かれている。しかしその方針に無理があり、機能追加した部分が元のCommonMark仕様と矛盾を生じてしまっている箇所が至るところにある。
> 
> 「加筆のみで原文や章立ては変えない」という方針のため、章の辻褄が合わなかったり、用語が矛盾している箇所が多い。典型例が[Disallowed Raw HTML](https://github.github.com/gfm/#disallowed-raw-html-extension-)で、ここはGFM仕様では使用禁止のHTMLタグの説明箇所だが、色々な意味合いで間違えている。
> 
> まず使用禁止のHTMLタグは本来それがブロックかインラインかには関係ないのに表題が"Disallowed Raw HTML"なのがおかしい("Disallowed HTML Elements"とすべき)。
> 
> また書かれている禁止HTMLタグの大部分は`<style>`などレンダリングされない制御用情報なので、こういうことは本当はブロックでもインラインでもない別の章を設けて書くべき。しかしGFM仕様書は「章立ては変えず加筆のみ」という方針なのでそもそも無理がある(この方針では書けない)。
> 
> これ以上駄目出ししても意味はないのでこの辺で止めておくが、こういうことはどこかに書いて残しておきたい。ただし本文中に書くものではない。今はメモとしてここに残しておき、後で付録のどこかに移動予定。

## ブロック

Markdownの文法構成アイテムの中で、複数行で構成可能な[インライン]よりも大きな単位の構成を**ブロック**と呼ぶ。ブロックはその内部に[インライン]のシーケンスを複数個含むことができる。またブロックの内部に別のブロックを再帰的に含む事ができるものもある。

- ブロック
    - [パラグラフ]
    - [見出し]
    - [横線]
    - [表]
    - [コードブロック]
    - [ブロック引用]
    - [リスト]
    - [タスクリスト]
    - [HTMLブロック]

> **TODO**: GFM仕様書ではコンテナブロックとそうでないもの(葉ブロック)を明確に分けている。上記リストでは上の5つ(コードブロックまで)が葉ブロックで、ブロック引用から下の4つは別のブロックを再帰的に含むことができる。
> 
> しかし検討の途中で実際には単純に分離できないケースがあることが分かってきたため、ここでは分類をやめて一緒にした経緯がある。しかし当時はやることだらけでその理由を文章として残すのを忘れてしまった。その後1ヶ月以上経過し、今では理由の方を忘れてしまい困っている。思い出し中。
> 
> > 思い出した。実はGFM仕様書(というよりその前のCommonMark仕様書)に不備がある。HTMLブロックは葉ブロックの中の一部として書かれているが、コンテナブロックになる場合もある。例えば`<details>`を用いた場合、その内部にはあらゆる種類の文法アイテムを再帰的に構造化できる。
> > 
> > つまりHTMLブロックがコンテナブロックなのか、葉ブロックなのかはタグ種類に依存する。`<p>`や`<div>`なら葉ブロックだし、再帰可能な要素種類ならコンテナブロックになる。試しにMarkdownで`<table>`内のセル(`<td>`)内に別のテーブルをネストして作ってみたらちゃんと出来た。
> > 
> > 結論としてCommonMark仕様書は現在の実用Markdown実装とは矛盾しており(間違いとは言い切れない可能性もあるので表現は抑える)、HTMLブロックは必ず葉ブロックではなく、要素種類によりコンテナブロックになる場合もある。

> **TODO**(検討記録): Markdownは責任を持って変換すべき部分は変換するが、HTMLタグは可能であればそのまま無変換で出力しているだけと解釈すれば説明は付く。そしてCommonMark仕様ではHTMLブロックが再帰可能ということを考慮していないためこの場所に記述が配置されただけのことだと考えられる。
> 
> しかしこれ(葉ブロック扱いになっていること)は明らかに誤りで、表のセルの中に別の表をネストして入れることはできる。また`<details>`の中に別の`<details>`をネストもできる。ならばコンテナブロックとして扱うのはどうか。
> 
> ここは自分でまとめ直す(検討)。案はいくつか考えられるが、一番簡単そうなのはHTMLブロックは葉ブロックではなくコンテナブロックの側に入れるという案。しかしこれは正しくない。ブロック扱いのHTML要素には再帰を想定していないものも多い(分かりやすい例は`<p>`)。
> 
> (後で追加) HTMLの現行モデルも一通り勉強し、結局のところ内包やネストが可能かどうかは用いる要素の種類で異なるという予想通りの結論になった。またMarkdown側ではHTMLタグの検出は行うが、それ以上は実質的には何もせずそのまま出力して後はブラウザのHTMLパーサに任せているだけということも分かった。
> 
> 後は構成の問題、具体的にはブロックアイテムを「葉」と「コンテナ」に分けるかどうかの判断ということになる。Markdown文法では両者を明確に分けているが、HTMLブロックに関してはそもそも本格的なパースはしていない(HTMLタグと判別できるとだけ認識してそのまま出力)。
> 
> もし「葉」と「コンテナ」を分けるのであれば、HTMLブロックは別扱いで分類しないと辻褄が合わない。そうなるとやはり「葉」と「コンテナ」の区別自体に無理があると考えた方が自然に思える。
> 
> やはり葉とコンテナには分けない。包含や再帰が可能というのは個別の記述で説明する。

## 構文解析

まず大前提としてMarkdownには文法エラーというものはない。どのような入力でも受付け、HTMLとして表示可能な状態に変換して出力する。

> 認識困難な入力は多くの場合テキストと判断して最低限の文字参照変換処理を行い出力する。また[表]の見出し行よりデータ行の方がセル数が多い場合は余剰分を削除する(GitHub実装の場合)。詳細動作は実装に依存するが、いずれにせよ変換エラーということはなく、必ずHTMLとして表示可能な結果を出力する。

変換処理の際に構文解析を行うが、その際には[ブロック]の認識を優先して行い、その後で[インライン]を解析する。例としてまず次のようなMarkdownコードを考える。

```markdown
ABC _DEF
GHI_ JKL
```

結果はこうなる。

> ABC _DEF
> GHI_ JKL

この例では1行目`ABC _DEF`と2行目`GHI_ JKL`の間には改行が一つだけある。空行ではないため連結されて1つの[パラグラフ]\([ブロック])と認識される(1行扱い)。

> このルールは[ソフト改行]と呼ばれる。

次に結合されたパラグラフ内部のテキストをインラインとして解析する。ここで`_DEF`と(スペースを挿入して連結された)`GHI_`が評価され、この部分が[斜体]で表示される。

ところが次の例では状況が全く異なる。

```markdown
- ABC _DEF
- GHI_ JKL
```

2行とも先頭の`-`を検出して[リスト項目]と判定する。結果は次の通り。

> - ABC _DEF
> - GHI_ JKL

連続する[リスト項目]は全体で1つの[リスト]\([ブロック])を構成する。また個別の[リスト項目]もブロックで、二重の入れ子構造として扱われる。このケースでは`_DEF`と`GHI_`は別ブロックのインラインとして別々に扱われ、斜体ではなく通常文字として出力される。

------------------------------------------------------------------------

[文字と行](characters.md)
← [目次](index.md) →
[インライン](inlines.md)

[GitHub Markdown実装]: github-markdown.md
[HTMLインライン]: html-inlines.md
[HTMLブロック]: html-blocks.md
[インライン]: #インライン
[コードスパン]: code-spans.md
[コードブロック]: code-blocks.md
[ソフト改行]: paragraphs.md#ソフト改行
[タスクリスト]: task-lists.md
[パラグラフ]: paragraphs.md
[ブロック]: #ブロック
[ブロック引用]: block-quotes.md
[リスト]: lists.md
[リスト項目]: lists.md#リスト項目
[リンク]: links.md
[打ち消し線]: bold-italic-strikethrough.md#打ち消し線
[斜体]: bold-italic-strikethrough.md#斜体
[通常テキスト]: textual-content.md
[表]: tables.md
[太字]: bold-italic-strikethrough.md#太字
[太字、斜体、打ち消し線]: bold-italic-strikethrough.md
[画像]: images.md
[見出し]: headings.md
[横線]: horizontal-rules.md
